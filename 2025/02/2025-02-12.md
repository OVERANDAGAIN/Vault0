---
创建时间: 2025-二月-12日  星期三, 3:23:46 下午
---




### **问题 1：为什么 `obs[:,:,i]` 可以表示每个玩家的位置？**

#### **解析 `obs = obs_flatten[7:].reshape((self.world_height, self.world_width, self.player_num + 3))`**
- `obs_flatten[7:]` 是去掉了前 7 维的观测数据，剩余的数据用于描述环境的二维网格状态。
- `reshape((self.world_height, self.world_width, self.player_num + 3))`：
  - `self.world_height` 和 `self.world_width` 表示网格世界的高度和宽度，说明 `obs` 代表一个 2D 格式的环境状态。
  - `self.player_num + 3` 是通道维度：
    - 前 `self.player_num` 个通道分别代表每个玩家的位置。
    - 倒数第 3 个通道 `obs[:, :, -3]` 可能用于额外环境信息。
    - 倒数第 2 个通道 `obs[:, :, -2]` 代表鹿（stag）的位置。
    - 倒数第 1 个通道 `obs[:, :, -1]` 代表兔子（hare）的位置。

#### **为什么 `obs[:,:,i]` 代表玩家 i 的位置？**
```python
for i in range(self.player_num):
    cur_pos = np.nonzero(obs[:,:,i])
    if len(cur_pos[0]) == 0:
        new_state.extend([-1,-1])
    else:
        new_state.extend([cur_pos[0][0],cur_pos[1][0]])
```
- `obs[:,:,i]` 提取的是 **第 `i` 个玩家的通道**，这个通道的值是一个二维矩阵（`self.world_height x self.world_width`）。
- `np.nonzero(obs[:,:,i])` 找到该矩阵中 **非零元素的索引**，即玩家 `i` 的位置：
  - `cur_pos[0]`：行索引（y 坐标）。
  - `cur_pos[1]`：列索引（x 坐标）。

**示例**
假设 `self.world_height = 5, self.world_width = 5, self.player_num = 3`，`obs` 可能是：
```
obs[:,:,0]: 玩家 1 位置
[[0, 0, 0, 0, 0]
 [0, 1, 0, 0, 0]  (玩家 1 在 (1,1))
 [0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]]

obs[:,:,1]: 玩家 2 位置
[[0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]
 [0, 0, 1, 0, 0]  (玩家 2 在 (2,2))
 [0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]]

obs[:,:,2]: 玩家 3 位置
[[0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]
 [0, 0, 0, 1, 0]  (玩家 3 在 (3,3))
 [0, 0, 0, 0, 0]]
```
此时：
```python
cur_pos = np.nonzero(obs[:,:,0])  # 取玩家1的通道
cur_pos[0] = [1]  # y 坐标
cur_pos[1] = [1]  # x 坐标
new_state.extend([1,1])  # 存储玩家1的位置

cur_pos = np.nonzero(obs[:,:,1])  # 取玩家2的通道
cur_pos[0] = [2]  # y 坐标
cur_pos[1] = [2]  # x 坐标
new_state.extend([2,2])  # 存储玩家2的位置

cur_pos = np.nonzero(obs[:,:,2])  # 取玩家3的通道
cur_pos[0] = [3]  # y 坐标
cur_pos[1] = [3]  # x 坐标
new_state.extend([3,3])  # 存储玩家3的位置
```
如果 `cur_pos[0]` 为空（玩家不在地图上），那么存储 `[-1, -1]`，表示玩家消失或未出生。

---

### **问题 2：`self.discounted_stag_times` 表示什么意思？**
#### **定义**
```python
self.discounted_stag_times = np.array([0.5/(1-self.discount_factor)] * self.player_num, dtype=np.float32)
self.discounted_hare_times = np.array([0.5/(1-self.discount_factor)] * self.player_num, dtype=np.float32)
```
- 这里的 `self.discounted_stag_times` 和 `self.discounted_hare_times` 分别存储 **每个玩家参与捕猎鹿（stag）和兔子（hare）的折扣累积次数**。
- 计算公式 `0.5 / (1 - self.discount_factor)` 是一个无限几何级数求和的结果，表示 **未来捕猎的总期望贡献**。
- `self.discount_factor` 是 **折扣因子（通常 0 < γ < 1）**，用于计算长期收益的衰减。

#### **为何初始化？**
这个初始化方法意味着 **默认情况下，玩家捕猎鹿和兔子的概率是对等的（各 50%），并且随着时间步长增加，这个比例会有所变化**。

---

### **调整 `self.discounted_stag_times` 和 `self.discounted_hare_times`**
```python
self.discounted_stag_times = np.array([100, 165, 165, 165], dtype=np.float32)[:self.player_num]
self.discounted_hare_times = np.array([100, 35, 35, 35], dtype=np.float32)[:self.player_num]
```
- `self.discounted_stag_times` = `[100, 165, 165, 165]`
  - 第一个玩家捕猎鹿的时间贡献是 100，其他三个玩家是 165。
- `self.discounted_hare_times` = `[100, 35, 35, 35]`
  - 第一个玩家捕猎兔子的时间贡献是 100，其他三个玩家是 35。

**为什么 `discounted_hare_times` 远小于 `discounted_stag_times`？**
- 可能表示玩家更倾向于捕猎鹿（stag），因为：
  - 鹿的奖励更高。
  - 需要合作才能成功捕获鹿，因此时间贡献较大。
  - 兔子容易被个体捕获，因此捕猎时间贡献较少。

**这个变量的作用**
- `self.stag_prob = self.discounted_stag_times / (self.discounted_hare_times + self.discounted_stag_times)`
  - 计算 **玩家更倾向于捕猎鹿的概率**。
  - 例如：
    ```python
    self.stag_prob = [100 / (100 + 100), 165 / (165 + 35), 165 / (165 + 35), 165 / (165 + 35)]
                 = [0.5, 0.825, 0.825, 0.825]
    ```
    - 玩家 1 选择鹿和兔子的概率相等（0.5）。
    - 其他玩家选择鹿的概率大于 0.8，说明他们更倾向于捕猎鹿。

- `self.hare_prob = 1 - self.stag_prob`
  - 计算 **玩家更倾向于捕猎兔的概率**。

---

### **总结**
1. `obs[:,:,i]` 代表玩家 `i` 在地图上的 **位置通道**，`np.nonzero(obs[:,:,i])` 识别出该玩家的具体位置。
2. `self.discounted_stag_times` 记录玩家 **累积的折扣捕猎鹿的时间贡献**，用于计算玩家的 **狩猎偏好**，并影响玩家后续的策略选择（例如更倾向于猎鹿还是猎兔）。
3. 这些参数用于动态调整玩家的策略，使其在不同环境下学习最优策略。










### **遍历所有对手后得到的 `self.stag_prob[i]` 是什么意思？**

#### **1. `self.stag_prob[i]` 的含义**
- 这是 **玩家 `i` 选择捕猎鹿（stag）的概率**，用于 **估计每个对手更倾向于捕猎鹿还是兔子**。
- 这个概率基于：
  - `self.stag_prob[i]`（上一时刻对 `i` 的估计）
  - `ac_prob_stag` 和 `ac_prob_hare`（玩家 `i` 在上一时刻的实际行为）
  - 通过归一化计算，确保 `self.stag_prob[i] + self.hare_prob[i] = 1`

**公式**
```python
self.stag_prob[i] = (self.stag_prob[i] * ac_prob_stag) / (
    self.stag_prob[i] * ac_prob_stag + self.hare_prob[i] * ac_prob_hare
)
```
- 这是一个 **贝叶斯更新公式**，即：
  - **原始的 `self.stag_prob[i]` 乘以 `ac_prob_stag`（对手实际行为的鹿选择概率）**
  - **对手也可能选择捕猎兔，因此分母是所有可能情况的总和**

---

#### **2. 遍历所有对手后的 `self.stag_prob` 结果**
最终 `self.stag_prob` 变成一个**长度为 `self.player_num` 的数组**，表示**当前玩家对每个玩家选择捕猎鹿的概率的估计**。

示例：
```python
self.stag_prob = [0.5, 0.8, 0.3, 0.9]  # 玩家 1, 2, 3, 4 分别选择捕猎鹿的概率
self.hare_prob = [0.5, 0.2, 0.7, 0.1]  # 玩家 1, 2, 3, 4 分别选择捕猎兔的概率
```
**解释：**
- **玩家 1**（自己）：50% 选择鹿，50% 选择兔。
- **玩家 2**（对手）：80% 选择鹿，20% 选择兔 → **偏好捕猎鹿**。
- **玩家 3**（对手）：30% 选择鹿，70% 选择兔 → **偏好捕猎兔**。
- **玩家 4**（对手）：90% 选择鹿，10% 选择兔 → **几乎总是选择捕猎鹿**。

---

#### **3. `self.stag_prob` 的用途**
这组概率用于：
1. **影响当前玩家的行动选择**
   - 如果大部分玩家都选择猎鹿（stag），那么自己可能更倾向于合作猎鹿，而不是独自去猎兔。
   - 反之，如果其他人都去猎兔，自己可能也更倾向于猎兔，以免鹿猎捕失败。

2. **影响蒙特卡洛树搜索（MCTS）计算**
   - 这些概率用于 MCTS 计算，每个对手的行为建模时，会根据这些概率进行动作采样，来模拟整个回合的未来走向。

3. **影响强化学习中的奖励估计**
   - 如果 `self.stag_prob` 低（比如大部分人猎兔），那么算法可能会调整策略，减少尝试猎鹿的概率，以避免失败。

---

### **总结**
- `self.stag_prob[i]` 是**玩家 `i` 选择捕猎鹿的概率估计**。
- 遍历所有对手后，得到一个 **数组 `self.stag_prob`，每个元素表示对应玩家捕猎鹿的概率**。
- 这个结果影响：
  1. **自己的决策**
  2. **蒙特卡洛树搜索（MCTS）计算**
  3. **强化学习的策略更新**
  
最终，`self.stag_prob` 让当前玩家能够 **根据其他玩家的策略调整自己的行为**，更好地适应游戏环境。