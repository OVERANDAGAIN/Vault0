---
创建时间: 2025-二月-12日  星期三, 3:23:46 下午
---




### **问题 1：为什么 `obs[:,:,i]` 可以表示每个玩家的位置？**

#### **解析 `obs = obs_flatten[7:].reshape((self.world_height, self.world_width, self.player_num + 3))`**
- `obs_flatten[7:]` 是去掉了前 7 维的观测数据，剩余的数据用于描述环境的二维网格状态。
- `reshape((self.world_height, self.world_width, self.player_num + 3))`：
  - `self.world_height` 和 `self.world_width` 表示网格世界的高度和宽度，说明 `obs` 代表一个 2D 格式的环境状态。
  - `self.player_num + 3` 是通道维度：
    - 前 `self.player_num` 个通道分别代表每个玩家的位置。
    - 倒数第 3 个通道 `obs[:, :, -3]` 可能用于额外环境信息。
    - 倒数第 2 个通道 `obs[:, :, -2]` 代表鹿（stag）的位置。
    - 倒数第 1 个通道 `obs[:, :, -1]` 代表兔子（hare）的位置。

#### **为什么 `obs[:,:,i]` 代表玩家 i 的位置？**
```python
for i in range(self.player_num):
    cur_pos = np.nonzero(obs[:,:,i])
    if len(cur_pos[0]) == 0:
        new_state.extend([-1,-1])
    else:
        new_state.extend([cur_pos[0][0],cur_pos[1][0]])
```
- `obs[:,:,i]` 提取的是 **第 `i` 个玩家的通道**，这个通道的值是一个二维矩阵（`self.world_height x self.world_width`）。
- `np.nonzero(obs[:,:,i])` 找到该矩阵中 **非零元素的索引**，即玩家 `i` 的位置：
  - `cur_pos[0]`：行索引（y 坐标）。
  - `cur_pos[1]`：列索引（x 坐标）。

**示例**
假设 `self.world_height = 5, self.world_width = 5, self.player_num = 3`，`obs` 可能是：
```
obs[:,:,0]: 玩家 1 位置
[[0, 0, 0, 0, 0]
 [0, 1, 0, 0, 0]  (玩家 1 在 (1,1))
 [0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]]

obs[:,:,1]: 玩家 2 位置
[[0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]
 [0, 0, 1, 0, 0]  (玩家 2 在 (2,2))
 [0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]]

obs[:,:,2]: 玩家 3 位置
[[0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]
 [0, 0, 0, 0, 0]
 [0, 0, 0, 1, 0]  (玩家 3 在 (3,3))
 [0, 0, 0, 0, 0]]
```
此时：
```python
cur_pos = np.nonzero(obs[:,:,0])  # 取玩家1的通道
cur_pos[0] = [1]  # y 坐标
cur_pos[1] = [1]  # x 坐标
new_state.extend([1,1])  # 存储玩家1的位置

cur_pos = np.nonzero(obs[:,:,1])  # 取玩家2的通道
cur_pos[0] = [2]  # y 坐标
cur_pos[1] = [2]  # x 坐标
new_state.extend([2,2])  # 存储玩家2的位置

cur_pos = np.nonzero(obs[:,:,2])  # 取玩家3的通道
cur_pos[0] = [3]  # y 坐标
cur_pos[1] = [3]  # x 坐标
new_state.extend([3,3])  # 存储玩家3的位置
```
如果 `cur_pos[0]` 为空（玩家不在地图上），那么存储 `[-1, -1]`，表示玩家消失或未出生。

---

### **问题 2：`self.discounted_stag_times` 表示什么意思？**
#### **定义**
```python
self.discounted_stag_times = np.array([0.5/(1-self.discount_factor)] * self.player_num, dtype=np.float32)
self.discounted_hare_times = np.array([0.5/(1-self.discount_factor)] * self.player_num, dtype=np.float32)
```
- 这里的 `self.discounted_stag_times` 和 `self.discounted_hare_times` 分别存储 **每个玩家参与捕猎鹿（stag）和兔子（hare）的折扣累积次数**。
- 计算公式 `0.5 / (1 - self.discount_factor)` 是一个无限几何级数求和的结果，表示 **未来捕猎的总期望贡献**。
- `self.discount_factor` 是 **折扣因子（通常 0 < γ < 1）**，用于计算长期收益的衰减。

#### **为何初始化？**
这个初始化方法意味着 **默认情况下，玩家捕猎鹿和兔子的概率是对等的（各 50%），并且随着时间步长增加，这个比例会有所变化**。

---

### **调整 `self.discounted_stag_times` 和 `self.discounted_hare_times`**
```python
self.discounted_stag_times = np.array([100, 165, 165, 165], dtype=np.float32)[:self.player_num]
self.discounted_hare_times = np.array([100, 35, 35, 35], dtype=np.float32)[:self.player_num]
```
- `self.discounted_stag_times` = `[100, 165, 165, 165]`
  - 第一个玩家捕猎鹿的时间贡献是 100，其他三个玩家是 165。
- `self.discounted_hare_times` = `[100, 35, 35, 35]`
  - 第一个玩家捕猎兔子的时间贡献是 100，其他三个玩家是 35。

**为什么 `discounted_hare_times` 远小于 `discounted_stag_times`？**
- 可能表示玩家更倾向于捕猎鹿（stag），因为：
  - 鹿的奖励更高。
  - 需要合作才能成功捕获鹿，因此时间贡献较大。
  - 兔子容易被个体捕获，因此捕猎时间贡献较少。

**这个变量的作用**
- `self.stag_prob = self.discounted_stag_times / (self.discounted_hare_times + self.discounted_stag_times)`
  - 计算 **玩家更倾向于捕猎鹿的概率**。
  - 例如：
    ```python
    self.stag_prob = [100 / (100 + 100), 165 / (165 + 35), 165 / (165 + 35), 165 / (165 + 35)]
                 = [0.5, 0.825, 0.825, 0.825]
    ```
    - 玩家 1 选择鹿和兔子的概率相等（0.5）。
    - 其他玩家选择鹿的概率大于 0.8，说明他们更倾向于捕猎鹿。

- `self.hare_prob = 1 - self.stag_prob`
  - 计算 **玩家更倾向于捕猎兔的概率**。

---

### **总结**
1. `obs[:,:,i]` 代表玩家 `i` 在地图上的 **位置通道**，`np.nonzero(obs[:,:,i])` 识别出该玩家的具体位置。
2. `self.discounted_stag_times` 记录玩家 **累积的折扣捕猎鹿的时间贡献**，用于计算玩家的 **狩猎偏好**，并影响玩家后续的策略选择（例如更倾向于猎鹿还是猎兔）。
3. 这些参数用于动态调整玩家的策略，使其在不同环境下学习最优策略。