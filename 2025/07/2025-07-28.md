---
创建时间: 2025-七月-28日  星期一, 3:10:22 下午
---



# 状态转移建模

## 公式：

$$
P(o_i^{t+1} \mid o_i^t, a_{-i}^t, a_i^t)
$$

> 给定当前观测 $o_i^t$、自身动作 $a_i^t$ 与对手动作 $a_{-i}^t$，
> 预测可能到达的下一状态 $o_i^{t+1}$ 的分布。
> 该模型承担“简化版模拟器”的作用，用于支撑后续的动作规划。



### 使用 直接计算loss(obs $\Longrightarrow$ next_obs)
```python
class Encoder(nn.Module):
    def __init__(self, latent_dim):
        super().__init__()
        self.net = nn.Sequential(
            nn.Conv2d(5, 32, kernel_size=3, padding=1),
            nn.ReLU(),
            nn.Conv2d(32, 64, kernel_size=3, padding=1),
            nn.ReLU(),
            nn.Flatten(),
            nn.Linear(64 * 4 * 4, latent_dim),
        )

    def forward(self, x):
        return self.net(x)
```
![[plot_2025-07-28 12-11-05_0.png]]
![[plot_2025-07-28 12-11-05_19.png]]

![[plot_2025-07-28 12-11-05_20.png]]

### 使用 隐变量 计算loss (obs $\Longrightarrow$ next_obs)
```python
    def forward(self, obs_t, self_action, opp_action):
        # 编码当前状态
        z_t = self.encoder(obs_t)

        # 预测下一状态隐变量
        z_t1 = self.dynamics(z_t, self_action, opp_action)

        # 解码下一状态
        obs_t1_pred = self.decoder(z_t1)
        return obs_t1_pred
```

![[plot_2025-07-28 15-31-25_30.png]]
![[plot_2025-07-28 15-31-25_27.png]]

![[plot_2025-07-28 15-31-25_29.png]]


![[plot_2025-07-28 15-31-25_28.png]]


## 直接重建obs (obs $\Longrightarrow$ obs)
![[plot_2025-07-28 12-21-16_51.png]]

![[plot_2025-07-28 12-21-16_50.png]]

规则简单，全观测。


## 代充网站：
9981store
F9HW5S67ZON6SUS4

![[Pasted image 20250728190710.png]]








