```
[tool.poetry]
name = "cleanrl"
version = "2.0.0b1"
description = "High-quality single file implementation of Deep Reinforcement Learning algorithms with research-friendly features"
authors = ["Costa Huang <costa.huang@outlook.com>"]
packages = [
    { include = "cleanrl" },
    { include = "cleanrl_utils" },
]
keywords = ["reinforcement", "machine", "learning", "research"]
license="MIT"
readme = "README.md"
[[tool.poetry.source]]
name = "tsinghua"
url = "https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/"
priority = "primary"
                            
[tool.poetry.dependencies]
python = ">=3.9,<3.11"
tensorboard = "^2.10.0"
wandb = "^0.13.11"
gym = "0.23.1"
#torch = ">=1.12.1"
torch = { url = "https://download.pytorch.org/whl/cu128/torch-2.8.0%2Bcu128-cp310-cp310-win_amd64.whl" }
torchvision = { url = "https://download.pytorch.org/whl/cu128/torchvision-0.23.0%2Bcu128-cp310-cp310-win_amd64.whl" }
torchaudio = { url = "https://download.pytorch.org/whl/cu128/torchaudio-2.8.0%2Bcu128-cp310-cp310-win_amd64.whl" }
stable-baselines3 = "2.0.0"
gymnasium = ">=0.28.1"
moviepy = "^1.0.3"
pygame = "2.1.0"
huggingface-hub = "^0.11.1"
rich = "<12.0"
tenacity = "^8.2.2"
tyro = "^0.5.10"
pyyaml = "^6.0.1"

ale-py = {version = "0.8.1", optional = true}
AutoROM = {extras = ["accept-rom-license"], version = "~0.4.2", optional = true}
opencv-python = {version = "^4.6.0.66", optional = true}
procgen = {version = "^0.10.7", optional = true}
pytest = {version = "^7.1.3", optional = true}
mujoco = {version = "<=2.3.3", optional = true}
imageio = {version = "^2.14.1", optional = true}
mkdocs-material = {version = "^8.4.3", optional = true}
markdown-include = {version = "^0.7.0", optional = true}
openrlbenchmark = {version = "^0.1.1b4", optional = true}
jax = {version = "0.4.8", optional = true}
jaxlib = {version = "0.4.7", optional = true}
flax = {version = "0.6.8", optional = true}
optuna = {version = "^3.0.1", optional = true}
optuna-dashboard = {version = "^0.7.2", optional = true}
envpool = {version = "^0.6.4", optional = true}
PettingZoo = {version = "1.18.1", optional = true}
SuperSuit = {version = "3.4.0", optional = true}
multi-agent-ale-py = {version = "0.1.11", optional = true}
boto3 = {version = "^1.24.70", optional = true}
awscli = {version = "^1.31.0", optional = true}
shimmy = {version = ">=1.1.0", optional = true}
dm-control = {version = ">=1.0.10", optional = true}
h5py = {version = ">=3.7.0", optional = true}
optax = {version = "0.1.4", optional = true}
chex = {version = "0.1.5", optional = true}
numpy = ">=1.21.6"
gif = "3.0.0"
seaborn = "0.12.2"

[tool.poetry.group.dev.dependencies]
pre-commit = "^2.20.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.poetry.extras]
atari = ["ale-py", "AutoROM", "opencv-python", "shimmy"]
procgen = ["procgen"]
plot = ["pandas", "seaborn"]
pytest = ["pytest"]
mujoco = ["mujoco", "imageio"]
jax = ["jax", "jaxlib", "flax"]
docs = ["mkdocs-material", "markdown-include", "openrlbenchmark"]
envpool = ["envpool"]
optuna = ["optuna", "optuna-dashboard"]
pettingzoo = ["PettingZoo", "SuperSuit", "multi-agent-ale-py"]
cloud = ["boto3", "awscli"]
dm_control = ["shimmy", "mujoco", "dm-control", "h5py"]

# dependencies for algorithm variant (useful when you want to run a specific algorithm)
dqn = []
dqn_atari = ["ale-py", "AutoROM", "opencv-python"]
dqn_jax = ["jax", "jaxlib", "flax"]
dqn_atari_jax = [
    "ale-py", "AutoROM", "opencv-python", # atari
    "jax", "jaxlib", "flax" # jax
]
c51 = []
c51_atari = ["ale-py", "AutoROM", "opencv-python"]
c51_jax = ["jax", "jaxlib", "flax"]
c51_atari_jax = [
    "ale-py", "AutoROM", "opencv-python", # atari
    "jax", "jaxlib", "flax" # jax
]
ppo_atari_envpool_xla_jax_scan = [
    "ale-py", "AutoROM", "opencv-python", # atari
    "jax", "jaxlib", "flax", # jax
    "envpool", # envpool
]
qdagger_dqn_atari_impalacnn = [
    "ale-py", "AutoROM", "opencv-python"
]
qdagger_dqn_atari_jax_impalacnn = [
    "ale-py", "AutoROM", "opencv-python", # atari
    "jax", "jaxlib", "flax", # jax
]




```


好的，我们重新进行规划，专注于技术核心内容，排除引言和总结部分，确保每位同学讲解20分钟实质性的技术内容。

以下是为五位同学设计的深度技术分工方案：

---

### **总体结构逻辑：**
汇报将分为两大部分：**第一部分（同学1和2）** 深入讲解证明下界的第一种工具——代数决策树模型。**第二部分（同学3、4和5）** 深入讲解证明下界的第二种工具——线性时间规约，并通过案例和扩展将其讲透。

---

### **同学1：代数决策树模型的基础与形式化定义**

*   **核心任务：** 严格定义模型并阐明其能力范围。
*   **内容分解：**
    1.  **从比较模型到代数决策树的演进 (5分钟)**
        *   简要回顾基于比较的决策树模型及其局限性（只能处理“比较”操作）。
        *   引出需求：我们需要一个更强大的模型来分析涉及更多计算（如加法、乘法）的问题（如元素唯一性、凸包、点集问题）。
    2.  **代数决策树的正式定义 (10分钟)**
        *   详细定义模型的每个组件：**输入**（实数值向量）、**计算节点**（执行一个代数操作或判断一个代数谓词，如 `f(x1,...,xn) : 0`）、**分支**（判断结果）、**叶子节点**（输出答案）。
        *   强调其计算能力：允许使用基本代数操作和常数次多项式的判断。
        *   形式化地定义算法的**复杂度**：由树的高度（最坏情况下的判断次数）决定。
    3.  **适用的问题领域与示例 (5分钟)**
        *   列举典型可用该模型分析的问题：**元素唯一性（Element Distinctness, ED）**、**集合相等性**、**凸包**、**最近点对**等。
        *   详细描述其中一个问题（如ED）的输入和输出，并讨论为什么它超出了比较模型的范围，为同学2的证明做铺垫。

---

### **同学2：代数决策树下界证明技术：Ben-Or定理与应用**

*   **核心任务：** 深入讲解基于拓扑的证明方法，并以一个完整问题为例进行证明。
*   **内容分解：**
    1.  **Ben-Or定理的介绍与直观理解 (5分钟)**
        *   陈述定理：一个问题的代数决策树复杂度下界由其输入空间中不同“输出区域”的连通分量数量的对数决定。
        *   **直观解释**：将每个输入实例看作高维空间中的一个点。算法通过判断将空间不断划分，最终每个“叶子”对应一个连通区域。区域越多，树就必须越深才能区分它们。
        *   介绍关键概念：**仿射映射**、**连通分量**（不需深入拓扑定义，强调其“可分离性”即可）。
    2.  **定理的证明思路（Sketch）(5分钟)**
        *   不进行完整数学证明，但解释证明的核心步骤和思想：
            *   树的每个节点对应一个代数集合。
            *   树的执行路径将输入空间划分成若干细胞（cells）。
            *   每个细胞必须是连通的，且对应一个输出。
            *   树的高度限制了细胞的数量（最多 `3^h`）。
            *   因此，若连通分量数量为C，则必有 `3^h >= C`，故 `h >= Ω(log C)`。
    3.  **实例分析：元素唯一性（ED）问题的Ω(n log n)下界证明 (10分钟)**
        *   计算ED问题的连通分量数量C：对于“是”实例（所有元素唯一），输入空间位于超平面 `x_i = x_j` 的补集中，形成了至少 `n!` 个连通分量（由元素的排列顺序决定）。
        *   代入定理： `h >= Ω(log(n!)) = Ω(n log n)`。
        *   完整地走通这个证明，这是本部分的高潮。

---

### **同学3：线性时间规约的理论框架与设计原则**

*   **核心任务：** 建立规约的理论基础，并讲解如何设计一个规约。
*   **内容分解：**
    1.  **为何需要规约：下界证明的传递 (5分钟)**
        *   指出代数决策树模型的局限性（仅适用于特定问题）。
        *   提出规约的核心价值：**将已知问题的下界传递到新问题上**，极大扩展了下界证明的范围。
    2.  **线性时间规约的严格数学定义 (10分钟)**
        *   形式化定义：给定问题A和B，若存在一个函数 `f`，满足：
            *   `f` 可在 **O(n)** 时间内计算（n为B实例的规模）。
            *   对于B的任何一个实例 `x`，`x` 的解为“是” **当且仅当** `f(x)` 作为A的实例，其解为“是”。
        *   则称 **B可线性时间规约到A**，记作 `B ≤ₗₜ A`。
        *   详细解释定义中的每个条件（时间约束、解等价性）。
        *   证明关键定理：若 `B ≤ₗₜ A` 且 `B` 的复杂度下界为 `Ω(T(n))`，则 `A` 的复杂度下界为 `Ω(T(n))` （考虑输入规模变化，进行详细分析）。
    3.  **规约的设计方法论与技巧 (5分钟)**
        *   讨论设计规约的思维过程：如何发现两个问题结构上的相似性。
        *   介绍常见技巧：**利用输入编码**、**构造特定结构**（如将数字映射为几何点）、**保持解的特性**。

---

### **同学4：线性时间规约实践I：从排序与凸包到ED**

*   **核心任务：** 通过一个经典、相对简单的规约案例，让观众彻底理解规约是如何构造和工作的。
*   **内容分解：**
    1.  **案例选择与背景设定 (3分钟)**
        *   明确目标：证明**凸包（Convex Hull, CH）** 问题在代数决策树模型下也有 `Ω(n log n)` 的下界。
        *   已知：元素唯一性（ED）的下界是 `Ω(n log n)`。
        *   计划：证明 `ED ≤ₗₜ Sorting`，再证明 `Sorting ≤ₗₜ CH`。从而通过传递性，证明 `ED ≤ₗₜ CH`。
    2.  **规约1：ED ≤ₗₜ Sorting (7分钟)**
        *   **构造**：将ED的输入（一组实数）直接作为排序算法的输入。
        *   **证明**：对排序后的结果，只需线性扫描一遍检查是否有相邻元素相等，即可解决ED问题。
        *   **分析**：规约函数 `f` 是恒等函数，显然是线性的。因此 `ED ≤ₗₜ Sorting`。
    3.  **规约2：Sorting ≤ₗₜ Convex Hull (10分钟)**
        *   **构造（核心）**：将待排序的n个实数 `{x1, x2, ..., xn}`，映射为2D平面上的点 `{(x1, x1²), (x2, x2²), ..., (xn, xn²)}`（即抛物线上的点）。
        *   **证明**：
            *   解释这些点在抛物线上的凸包必然是一个凸链，计算其凸包（如使用Graham Scan），输出的顶点按x坐标自然就是排序好的序列。
            *   证明其正确性：因为抛物线是凸的，所有点都在凸包上，且x坐标的顺序与凸包顺序一致。
        *   **分析**：映射过程是线性时间。因此 `Sorting ≤ₗₜ CH`。
        *   结合两个规约，得出结论。

---

### **同学5：线性时间规约实践II：高级案例与扩展**

*   **核心任务：** 展示规约的更强大、更复杂的应用，拓宽视野。
*   **内容分解：**
    1.  **复习与引深 (2分钟)**
        *   简要回顾同学4的规约链，指出其相对直观。
        *   提出：规约可以处理更复杂的问题，下界可以更强。
    2.  **高级案例：3SUM问题的规约 (13分钟)**
        *   **介绍3SUM问题**：给定一个包含n个整数的集合，是否存在三个数之和为0？
        *   **介绍其猜想**：3SUM问题不存在优于 `O(n²)` 的算法（这是一个非常著名的猜想，是很多下界证明的源头）。
        *   **选择一个规约示例**：例如，证明**共线三点问题**（给定n个点，是否存在三点共线？）是3SUM难的。
        *   **规约构造**：详细演示如何将一个3SUM实例（数组A）转化为一个共线三点问题的实例（点集S）。
            *   经典构造：将数字 `a` 映射为点 `(a, a³)`。
            *   利用性质：三个点 `(a, a³), (b, b³), (c, c³)` 共线的条件可推导出 `a + b + c = 0`。
        *   **分析**：解释该映射是线性时间的，且解等价。因此，如果共线三点问题有优于 `O(n²)` 的算法，则3SUM问题也有，这与猜想矛盾。
    3.  **扩展讨论 (5分钟)**
        *   **基于猜想的规约**：说明很多现代下界证明依赖于像3SUM、SETH（强指数时间假说）这样的猜想，并解释其意义。
        *   **其他类型的规约**：简要提及**随机化规约**和**近似性保持规约**，说明规约理论在复杂性研究中的广度。
        *   结束语：强调规约是连接不同问题复杂性的桥梁，是理论计算机科学家的核心工具包。