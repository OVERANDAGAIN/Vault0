下面我把你这张图的含义用**最简洁但数学上完全正确**的公式表达出来，
并给出两种版本（论文风格 / 工程风格），你可以直接贴图旁边。

---

# ✅ **核心逻辑（一句话）**

> 从未来 (H) 个状态 ({o_{t},o_{t+1},\dots,o_{t+H-1}}) 中，
> 选择 **价值函数 (V_\theta)** 最大的那个状态作为目标状态 (o_g)。

---

# ⭐ **最简公式（强烈推荐给你的图用）**

[
o_g =\underset{o_{t+k}}{\arg\max} V_\theta\left(o_{t+k}, g_{t+k}\right),
\quad k = 0,\dots,H-1
]

---

# 解释

* 你未来的窗口是
  [
  {o_{t},, o_{t+1},, \dots,, o_{t+H-1}}
  ]
* 对每个未来状态，你计算价值：
  [
  V_\theta(o_{t+k}, g_{t+k})
  ]
* 选出价值最高的那个：
  [
  o_g
  ]

这个就是图里往下箭头到 (o_g) 的完整数学表示。

---

# ⭐ 如果你未来不想写 subgoal，可用更极简版：

[
o_g = \arg\max_{k \in {0,\dots,H-1}} V_\theta(o_{t+k})
]

---

# ⭐ 如果你想从状态里输出目标 embedding，而不是状态本身（例如输出 (g_g)）：

[
g_g = g_{t+k^*},\qquad
k^* = \arg\max_{k=0..H-1} V_\theta(o_{t+k}, g_{t+k})
]

---

# ⭐ 工程风格伪代码（如需写逻辑说明）

```pseudo
best_value = -∞
best_state = None
for k = 0 .. H-1:
    v = V_theta(o[t+k], g[t+k])
    if v > best_value:
        best_value = v
        best_state = o[t+k]
o_g = best_state
```

---

# ⭐ 论文中一句话描述（如果要写段落）

> Given a horizon (H), we evaluate the value function over the next (H) future states and select the one with the highest estimated return.
> Formally,
> [
> o_g = \arg\max_{k \in {0,\dots,H-1}} V_\theta(o_{t+k}, g_{t+k}).
> ]

---

如果你想，我可以把这一块帮你直接画成“Method 图组件”嵌在你的大图里，让整体风格一致。
